# Active Taxis Data Dictionary

## Overview

The **Active Taxis** datasets count the number of unique taxis present in an n×n grid neighborhood for each spatiotemporal state. These datasets enable efficient lookup of active taxi counts for the Spatial Fairness and Causal Fairness objective function terms, eliminating the need to process raw GPS data during runtime calculations. An "active taxi" is defined as any taxi that had at least one GPS reading in the neighborhood during the specified time period.

**File Format:** Python pickle file (`.pkl`)  
**Data Type:** Dictionary with metadata bundle  
**Source Data:** Expert driver GPS trajectories from 50 drivers (July 2016)  
**Neighborhood:** Configurable n×n grid cells (default: 5×5)  
**Generated By:** `active_taxis` tool (FAMAIL/active_taxis/)

---

## Dataset Variants

Four primary dataset configurations are available, differing in temporal aggregation granularity:

| Dataset | Period Type | File Name | Keys Format | Periods | Use Case |
|---------|-------------|-----------|-------------|---------|----------|
| **Time Bucket** | 5-minute intervals | `active_taxis_n5x5_time_bucket.pkl` | `(x, y, bucket, day)` | 1,728 | Fine-grained temporal analysis |
| **Hourly** | 1-hour intervals | `active_taxis_n5x5_hourly.pkl` | `(x, y, hour, day)` | 144 | Standard temporal resolution |
| **Daily** | Full day | `active_taxis_n5x5_daily.pkl` | `(x, y, day)` | 6 | Day-level patterns |
| **All** | Entire period | `active_taxis_n5x5_all.pkl` | `(x, y, 'all')` | 1 | Aggregate analysis |

**Note:** File names include neighborhood size (e.g., `n5x5` = 5×5 neighborhood). Other sizes available: `n3x3` (k=1), `n7x7` (k=3).

---

## Data Structure

### File Bundle Structure

Each pickle file contains a bundle with three components:

```python
{
    'data': {key → count},        # The actual active taxi counts
    'stats': {...},               # Processing statistics
    'config': {...},              # Generation configuration
    'version': '1.0.0'            # Dataset version
}
```

### Loading the Data

```python
import pickle

# Load the dataset
with open('active_taxis_n5x5_hourly.pkl', 'rb') as f:
    bundle = pickle.load(f)

data = bundle['data']
stats = bundle['stats']
config = bundle['config']

# Check dataset properties
print(f"Total keys: {len(data):,}")
print(f"Neighborhood: {config['neighborhood_dims']}×{config['neighborhood_dims']}")
print(f"Period type: {config['period_type']}")

# Look up active taxi count for a specific state
# For hourly: (x, y, hour, day)
count = data.get((25, 45, 12, 3), 0)  # Cell (25,45), hour 12, Wednesday
print(f"Active taxis: {count}")
```

### Simplified Loading (Data Only)

```python
# Load just the data dictionary (for backward compatibility)
from active_taxis import load_output

data, stats_dict, config_dict = load_output('active_taxis_n5x5_hourly.pkl')

# Use directly
active_count = data[(x, y, hour, day)]
```

---

## Dataset 1: Time Bucket (5-Minute Intervals)

### Overview
- **Period Type:** `time_bucket`
- **Temporal Resolution:** 5-minute intervals (288 per day)
- **Total Keys:** 7,464,960 (48 × 90 × 288 × 6)
- **Use Case:** Fine-grained temporal analysis, peak detection

### Key Structure

```python
# Key format: (x_grid, y_grid, time_bucket, day_of_week)
key = (x, y, time_bucket, day)
```

| Index | Field | Type | Description | Range |
|-------|-------|------|-------------|-------|
| 0 | `x_grid` | `int` | Grid x-coordinate (latitude-based) | [1, 48] |
| 1 | `y_grid` | `int` | Grid y-coordinate (longitude-based) | [1, 90] |
| 2 | `time_bucket` | `int` | 5-minute interval index | [1, 288] |
| 3 | `day_of_week` | `int` | Day of week | [1, 6] |

### Time Bucket Mapping

```python
def time_bucket_to_time(bucket: int) -> str:
    """Convert 1-indexed time bucket to HH:MM format."""
    minutes = (bucket - 1) * 5
    hours = minutes // 60
    mins = minutes % 60
    return f"{hours:02d}:{mins:02d}"

# Examples:
# bucket 1   → 00:00 (midnight)
# bucket 144 → 11:55 (noon)
# bucket 288 → 23:55 (11:55 PM)
```

### Day of Week Mapping

```python
day_mapping = {
    1: 'Monday',
    2: 'Tuesday',
    3: 'Wednesday',
    4: 'Thursday',
    5: 'Friday',
    6: 'Saturday'
    # Sunday excluded from dataset
}
```

### Value Range

- **Minimum:** 0 (no taxis in neighborhood during period)
- **Maximum:** 50 (all taxis in dataset present in neighborhood)
- **Typical Range:** 0-15 for most cells, up to 30-40 in high-activity areas

### Example Usage

```python
# Get active taxis at a specific location and time
x, y = 25, 45                    # Central business district
time_bucket = 180                # 14:55 (2:55 PM)
day = 3                          # Wednesday

count = data[(x, y, time_bucket, day)]
print(f"Active taxis: {count}")

# Find peak activity time for a cell
cell_counts = []
for t in range(1, 289):
    count = data.get((x, y, t, 3), 0)
    cell_counts.append((t, count))

peak_bucket, peak_count = max(cell_counts, key=lambda x: x[1])
peak_time = time_bucket_to_time(peak_bucket)
print(f"Peak: {peak_count} taxis at {peak_time}")
```

---

## Dataset 2: Hourly (1-Hour Intervals)

### Overview
- **Period Type:** `hourly`
- **Temporal Resolution:** 1-hour intervals (24 per day)
- **Total Keys:** 622,080 (48 × 90 × 24 × 6)
- **Use Case:** Standard temporal analysis, service rate calculations

### Key Structure

```python
# Key format: (x_grid, y_grid, hour, day_of_week)
key = (x, y, hour, day)
```

| Index | Field | Type | Description | Range |
|-------|-------|------|-------------|-------|
| 0 | `x_grid` | `int` | Grid x-coordinate (latitude-based) | [1, 48] |
| 1 | `y_grid` | `int` | Grid y-coordinate (longitude-based) | [1, 90] |
| 2 | `hour` | `int` | Hour of day | [0, 23] |
| 3 | `day_of_week` | `int` | Day of week | [1, 6] |

### Hour Mapping

```python
# Hour 0-23 (standard 24-hour format)
hour_examples = {
    0: '00:00 - 00:59',
    6: '06:00 - 06:59',
    12: '12:00 - 12:59',
    18: '18:00 - 18:59',
    23: '23:00 - 23:59'
}
```

### Value Range

- **Minimum:** 0 (no taxis in neighborhood during hour)
- **Maximum:** 50 (all taxis present in neighborhood)
- **Typical Range:** 0-20 for most cells, up to 35-45 in high-activity areas

### Example Usage

```python
# Get active taxis during rush hour
x, y = 10, 15                    # Airport vicinity
hour = 17                        # 5:00 PM - 5:59 PM
day = 5                          # Friday

count = data[(x, y, hour, day)]
print(f"Active taxis during Friday rush hour: {count}")

# Compare morning vs evening rush hour
morning_count = data.get((x, y, 8, 3), 0)   # 8 AM Wednesday
evening_count = data.get((x, y, 17, 3), 0)  # 5 PM Wednesday
print(f"Morning: {morning_count}, Evening: {evening_count}")

# Calculate average active taxis for a cell across all hours
total = sum(data.get((x, y, h, 3), 0) for h in range(24))
avg = total / 24
print(f"Average active taxis: {avg:.1f}")
```

---

## Dataset 3: Daily (Full Day)

### Overview
- **Period Type:** `daily`
- **Temporal Resolution:** Entire day (no time-of-day differentiation)
- **Total Keys:** 25,920 (48 × 90 × 6)
- **Use Case:** Day-level comparisons, weekday pattern analysis

### Key Structure

```python
# Key format: (x_grid, y_grid, day_of_week)
key = (x, y, day)
```

| Index | Field | Type | Description | Range |
|-------|-------|------|-------------|-------|
| 0 | `x_grid` | `int` | Grid x-coordinate (latitude-based) | [1, 48] |
| 1 | `y_grid` | `int` | Grid y-coordinate (longitude-based) | [1, 90] |
| 2 | `day_of_week` | `int` | Day of week | [1, 6] |

### Value Range

- **Minimum:** 0 (no taxis in neighborhood during entire day)
- **Maximum:** 50 (all taxis present in neighborhood during the day)
- **Typical Range:** 5-35 for most cells

### Example Usage

```python
# Get active taxis for a cell on different days
x, y = 20, 30                    # Shopping district

for day in range(1, 7):
    count = data[(x, y, day)]
    day_name = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][day-1]
    print(f"{day_name}: {count} active taxis")

# Find day with highest activity
day_counts = [(d, data[(x, y, d)]) for d in range(1, 7)]
peak_day, peak_count = max(day_counts, key=lambda x: x[1])
print(f"Peak activity on day {peak_day}: {peak_count} taxis")
```

---

## Dataset 4: All (Aggregate)

### Overview
- **Period Type:** `all`
- **Temporal Resolution:** Entire dataset period (all time aggregated)
- **Total Keys:** 4,320 (48 × 90)
- **Use Case:** Overall spatial patterns, baseline comparisons

### Key Structure

```python
# Key format: (x_grid, y_grid, 'all')
key = (x, y, 'all')
```

| Index | Field | Type | Description | Range |
|-------|-------|------|-------------|-------|
| 0 | `x_grid` | `int` | Grid x-coordinate (latitude-based) | [1, 48] |
| 1 | `y_grid` | `int` | Grid y-coordinate (longitude-based) | [1, 90] |
| 2 | `period` | `str` | Period identifier | `'all'` |

### Value Range

- **Minimum:** 0 (no taxis ever in neighborhood)
- **Maximum:** 50 (all taxis present in neighborhood at some point)
- **Typical Range:** 10-45 for most active cells

### Example Usage

```python
# Get total unique active taxis for a cell
x, y = 15, 25
count = data[(x, y, 'all')]
print(f"Total unique active taxis: {count}")

# Create spatial heatmap
import numpy as np

grid = np.zeros((48, 90))
for x in range(1, 49):
    for y in range(1, 91):
        grid[x-1, y-1] = data.get((x, y, 'all'), 0)

# Find cells with highest overall activity
max_val = grid.max()
max_cells = np.argwhere(grid == max_val)
print(f"Max active taxis: {max_val}")
print(f"Cells with max activity: {max_cells + 1}")  # +1 for 1-indexing
```

---

## Coordinate System

### Grid Indexing

All datasets use **1-indexed** coordinates to match `pickup_dropoff_counts.pkl`:

- **x_grid:** 1 to 48 (latitude-based, north-south)
- **y_grid:** 1 to 90 (longitude-based, east-west)
- **Grid size:** 0.01 degrees per cell (~1.1 km at Shenzhen's latitude)

### Spatial Bounds

Based on Shenzhen GPS data from July 2016:

```python
bounds = {
    'lat_min': 22.52,      # Southern edge
    'lat_max': 22.99,      # Northern edge
    'lon_min': 113.85,     # Western edge
    'lon_max': 114.74,     # Eastern edge
}
```

### Grid Offset (Important!)

The quantization includes offsets to align with existing datasets:

```python
# Raw digitize output (0-indexed)
x_raw = np.digitize(latitude, lat_bins) - 1
y_raw = np.digitize(longitude, lon_bins) - 1

# Applied offsets to match pickup_dropoff_counts
x_grid = x_raw + 1  # x_grid_offset = 1
y_grid = y_raw + 1  # y_grid_offset = 1
```

This ensures perfect alignment with pickup and dropoff event locations.

---

## Neighborhood Definition

### Neighborhood Size Parameter

The neighborhood size is defined by parameter **k**, where the neighborhood consists of a **(2k+1) × (2k+1)** grid of cells centered on the target cell.

| k | Neighborhood Size | Cells Included | Description |
|---|-------------------|----------------|-------------|
| 0 | 1×1 | 1 | Just the cell itself |
| 1 | 3×3 | 9 | Cell + immediate neighbors |
| 2 | 5×5 | 25 | Standard (default) |
| 3 | 7×7 | 49 | Large neighborhood |

### Boundary Handling

Neighborhoods at grid boundaries are automatically clipped:

```python
# Example: Corner cell (1, 1) with k=2
# Requested neighborhood: (-1 to 3, -1 to 3)
# Actual neighborhood (clipped): (1 to 3, 1 to 3) = 3×3 instead of 5×5
```

Cells at boundaries have smaller effective neighborhoods, resulting in potentially lower active taxi counts.

### Neighborhood Calculation

```python
def get_neighborhood_cells(x: int, y: int, k: int, 
                          grid_dims: tuple = (48, 90)) -> list:
    """Get all cells in (2k+1)×(2k+1) neighborhood."""
    x_max, y_max = grid_dims
    cells = []
    
    for dx in range(-k, k + 1):
        for dy in range(-k, k + 1):
            nx, ny = x + dx, y + dy
            if 1 <= nx <= x_max and 1 <= ny <= y_max:
                cells.append((nx, ny))
    
    return cells

# Example: 5×5 neighborhood for cell (25, 45)
neighborhood = get_neighborhood_cells(25, 45, k=2)
# Returns 25 cells: (23-27, 43-47)
```

---

## Value Semantics

### What "Active Taxi Count" Means

For a given spatiotemporal key `(x, y, *period)`:

1. **Identify the neighborhood:** All cells within (2k+1)×(2k+1) of (x, y)
2. **Find taxis present:** Any taxi with ≥1 GPS reading in the neighborhood during the period
3. **Count unique taxis:** The number of distinct taxi IDs

**Important:** A taxi is counted once even if it has multiple GPS readings in the neighborhood.

### Interpretation

```python
# Example: data[(25, 45, 12, 3)] = 18
# Interpretation:
#   - Cell: (25, 45)
#   - Time: Hour 12 (noon-1pm), Wednesday
#   - Neighborhood: 5×5 cells centered on (25, 45)
#   - Result: 18 unique taxis had GPS readings in this neighborhood during this hour
```

### Use in Spatial Fairness

The Spatial Fairness term uses active taxi counts to compute service rates:

$$\text{DSR}_s^p = \frac{\text{pickups}_s^p}{N_s^p \cdot T}$$

Where:
- $\text{pickups}_s^p$ = pickup count in cell $s$ during period $p$ (from `pickup_dropoff_counts`)
- $N_s^p$ = active taxi count (from this dataset)
- $T$ = duration of period in days

```python
# Example calculation
from active_taxis import load_output
from pickup_dropoff_counts import load_output as load_pd

active_data, _, _ = load_output('active_taxis_n5x5_hourly.pkl')
pd_data = load_output('pickup_dropoff_counts.pkl')

x, y, hour, day = 25, 45, 12, 3

# Get active taxis
N = active_data[(x, y, hour, day)]

# Get pickups (need to aggregate time buckets for this hour)
pickups = sum(
    pd_data.get((x, y, hour*12 + tb + 1, day), (0, 0))[0]
    for tb in range(12)  # 12 five-minute buckets per hour
)

# Calculate departure service rate
T = 1/24  # 1 hour = 1/24 days
DSR = pickups / (N * T) if N > 0 else 0

print(f"Departure Service Rate: {DSR:.2f} pickups per taxi per day")
```

---

## Data Quality and Coverage

### Completeness

All datasets include **every possible spatiotemporal key** for their respective granularity, including keys with zero active taxis. This ensures:

- No missing keys (complete coverage)
- Efficient lookups without key existence checks
- Consistent dimensions for array-based operations

### Data Source

- **GPS Data:** `taxi_record_07_50drivers.pkl` (July 2016 weekdays)
- **Drivers:** 50 expert taxi drivers
- **Days:** 21 weekdays (Mondays-Saturdays, Sundays excluded)
- **GPS Readings:** ~2.4 million records

### Spatial Coverage

Not all grid cells have active taxis:

```python
# Typical coverage (for hourly dataset):
# - Cells with 0 active taxis: ~87% (sparse urban coverage)
# - Cells with 1+ active taxis: ~13% (active areas)
# - Cells with 5+ active taxis: ~0.2% (high-activity zones)
```

### Temporal Patterns

Expected patterns in the data:

1. **Time-of-day variation:**
   - Low: 2-5 AM (few taxis active)
   - High: 8-9 AM, 5-7 PM (rush hours)

2. **Day-of-week variation:**
   - Higher on Fridays (weekend travel)
   - Lower on Mondays (post-weekend)

3. **Spatial concentration:**
   - Highest near airports, train stations
   - Business districts during business hours
   - Residential areas during off-peak hours

---

## Generation Configuration

### Metadata in Bundle

Each dataset includes the configuration used for generation:

```python
config = bundle['config']
print(config)
# Output:
# {
#     'neighborhood_size': 2,
#     'neighborhood_dims': 5,
#     'period_type': 'hourly',
#     'grid_size': 0.01,
#     'grid_dims': (48, 90),
#     'exclude_sunday': True,
#     'x_grid_offset': 1,
#     'y_grid_offset': 1,
#     'time_offset': 1,
#     'test_mode': False,
#     'input_files': ['taxi_record_07_50drivers.pkl']
# }
```

### Processing Statistics

```python
stats = bundle['stats']
print(stats)
# Output:
# {
#     'total_records': 2400000,
#     'records_after_sunday_filter': 2040000,
#     'unique_taxis': 50,
#     'unique_cells': 892,
#     'unique_periods': 144,
#     'max_active_taxis_in_cell': 47,
#     'avg_active_taxis_per_cell': 3.21,
#     'total_output_keys': 622080,
#     'processing_time_seconds': 247.3,
#     'global_bounds': {
#         'lat_min': 22.5234,
#         'lat_max': 22.9876,
#         'lon_min': 113.8523,
#         'lon_max': 114.7398
#     }
# }
```

---

## Integration with FAMAIL Components

### Spatial Fairness Term

```python
from objective_function.spatial_fairness import SpatialFairnessTerm, SpatialFairnessConfig
from active_taxis import load_output

# Load active taxi data
active_data, _, _ = load_output('active_taxis_n5x5_hourly.pkl')

# Configure spatial fairness to use active taxi data
config = SpatialFairnessConfig(
    period_type='hourly',
    use_active_taxi_data=True,
)

# Compute spatial fairness
term = SpatialFairnessTerm(config)
result = term.compute(
    {},
    {
        'pickup_dropoff_counts': pickup_data,
        'active_taxis': active_data,
    }
)
```

### Causal Fairness Term (Future)

The Causal Fairness term will use active taxi counts to determine the set of taxis that could have influenced outcomes in each region.

---

## File Size Estimates

| Dataset | Keys | Approx Size |
|---------|------|-------------|
| Time Bucket | 7,464,960 | ~60-80 MB |
| Hourly | 622,080 | ~5-8 MB |
| Daily | 25,920 | ~200-300 KB |
| All | 4,320 | ~50-100 KB |

---

## Validation and Quality Checks

### Expected Properties

1. **Bounds:** `0 ≤ count ≤ 50` for all keys
2. **Spatial correlation:** Adjacent cells should have similar counts
3. **Temporal patterns:** Higher counts during peak hours
4. **Neighborhood effect:** Larger neighborhoods → higher average counts
5. **Monotonicity:** For same (x,y,day): hourly aggregation ≥ any individual hour

### Validation Example

```python
# Check bounds
assert all(0 <= v <= 50 for v in data.values())

# Check spatial correlation (example for one hour)
import numpy as np
grid = np.zeros((48, 90))
for x in range(1, 49):
    for y in range(1, 91):
        grid[x-1, y-1] = data.get((x, y, 12, 3), 0)

# Adjacent cells should be correlated
from scipy.stats import pearsonr
adjacent_diffs = []
for x in range(1, 48):
    for y in range(1, 90):
        diff = abs(grid[x, y] - grid[x-1, y])
        adjacent_diffs.append(diff)

avg_diff = np.mean(adjacent_diffs)
print(f"Average difference between adjacent cells: {avg_diff:.2f}")
# Expected: Low values (1-3) indicate spatial correlation
```

---

## Common Use Cases

### 1. Service Rate Calculation

```python
# Calculate departure service rate for all cells in a period
hour, day = 12, 3
T = 1/24  # 1 hour in days

for x in range(1, 49):
    for y in range(1, 91):
        N = active_data[(x, y, hour, day)]
        if N > 0:
            pickups = get_pickups(x, y, hour, day)  # From pickup_dropoff_counts
            DSR = pickups / (N * T)
```

### 2. Temporal Analysis

```python
# Analyze how active taxi count varies throughout the day
x, y, day = 25, 45, 3

hourly_counts = []
for hour in range(24):
    count = data[(x, y, hour, day)]
    hourly_counts.append(count)

import matplotlib.pyplot as plt
plt.plot(range(24), hourly_counts)
plt.xlabel('Hour of Day')
plt.ylabel('Active Taxis')
plt.title(f'Active Taxis at Cell ({x},{y}) on {day_names[day-1]}')
plt.show()
```

### 3. Spatial Heatmap

```python
# Create heatmap of average active taxis
import numpy as np

grid = np.zeros((48, 90))
for x in range(1, 49):
    for y in range(1, 91):
        # Average across all periods
        total = sum(data.get((x, y, h, d), 0) 
                   for h in range(24) 
                   for d in range(1, 7))
        grid[x-1, y-1] = total / (24 * 6)

# Plot with your preferred visualization library
```

---

## Related Datasets

| Dataset | Relationship | Key Format |
|---------|--------------|------------|
| `pickup_dropoff_counts.pkl` | Provides pickup/dropoff counts for same spatiotemporal keys | `(x, y, time_bucket, day)` |
| `latest_volume_pickups.pkl` | Similar but includes traffic volume features | `(x, y, time_bucket, day)` |
| `all_trajs.pkl` | Raw trajectories from which both are derived | Variable length state sequences |
| `taxi_record_XX_50drivers.pkl` | Original GPS data source | Nested driver records |

---

## Version History

- **v1.0.0** (January 2026): Initial release with four period types

---

## References

- FAMAIL Active Taxis Tool: `/FAMAIL/active_taxis/`
- Generation Algorithm: `/FAMAIL/active_taxis/docs/algorithm.md`
- Spatial Fairness Term: `/FAMAIL/objective_function/spatial_fairness/`
- Pickup/Dropoff Counts: `/FAMAIL/pickup_dropoff_counts/`
